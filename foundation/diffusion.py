# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_diffusion.ipynb.

# %% auto 0
__all__ = ['corrupt', 'BasicUNet']

# %% ../nbs/10_diffusion.ipynb 4
import torch
from torch import nn
from torch.nn import functional as F
from torch.utils.data import DataLoader
import torchvision

from diffusers import DDPMScheduler, UNet2DModel
from matplotlib import pyplot as plt
from fastcore.foundation import L

from .utils import show_img

# %% ../nbs/10_diffusion.ipynb 16
def corrupt(img, amount):
    noise = torch.randn_like(img)
    return (1-amount)*img + noise * amount

# %% ../nbs/10_diffusion.ipynb 25
class BasicUNet(nn.Module):
    """A minimal UNet implementation."""
    def __init__(self, in_channels, out_channels):
        super().__init__()
        self.down_layers = torch.nn.ModuleList([ 
            nn.Conv2d(in_channels, 32, kernel_size=5, padding=2),
            nn.Conv2d(32, 64, kernel_size=5, padding=2),
            nn.Conv2d(64, 64, kernel_size=5, padding=2),
        ])
        self.up_layers = torch.nn.ModuleList([
            nn.Conv2d(64, 64, kernel_size=5, padding=2),
            nn.Conv2d(64, 32, kernel_size=5, padding=2),
            nn.Conv2d(32, out_channels, kernel_size=5, padding=2), 
        ])
        self.act = nn.SiLU()
        self.downscale = nn.MaxPool2d(2)
        self.upscale = nn.Upsample(scale_factor=2)

    def forward(self, x):
        h = []
        for i, l in enumerate(self.down_layers):
            x = self.act(l(x))
            h.append(x)
            if i < 2: x = self.downscale(x)
        for i, l in enumerate(self.up_layers):
            if i > 0: x = self.upscale(x)
            x += h.pop()
            x = self.act(l(x))
        return x
